"""
처음 생각 했을 땐 앞에서부터 i번째부터 끝까지 최대값과 i번째를 비교하면서 자기 자신이 최대값이라면 그전에 가지고 있던 주식을 팔고 아니라면 price에서 자신만큼 -하고 주식 개수를
늘리면 되지 않나? 하고 생각하고 코드를 짰다. 하지만 역시 첫번째로 작성한게 들어 맞을리가 없는지 시간제한이 떴고 그 이유는 max의 시간복잡도 n 덕에 n^3으로 늘어난것이 원인이였고
max를 안쓰고 할 방법을 생각해야 했다.
다음 방법은 주식은 결국 매도가격과 매수가격의 차익이다 7에사서 10에서 팔았으면 3의 이득을 얻었듯 리스트 뒤에서부터 자익으로 계산하면 어떨까라고 생각했다.
앞에서부터 계산한다면 최대값 이후 어떤게 최대값일지 모른다 하지만 뒤에서부터 계산하면 최대값을 몰라도 된다
지금의 최대값보다 현재 값이 크다면 바꿔주고 아니라면 최대값과의 차익을 계산하면끝이다
예시로 1 1 3 1 4 1 3 1 2가 있다면
앞에서부터 인데스를 +1 하면 어느시점이 최고가인지 모른다 하지만 뒤에서부터 -1 하면
처음엔 최대값 0
2를 만났으니 현재값이 > 최대값임
최대값 2로 갱신
1를 만났으니 현재값이 < 최대값임
따지자면 결국 2를 만나기전에 샀을테니 차익인 2-1로 계산
...
를 하면 답이 나온다
또 다른 설명으로 이해를 하자면
1 1 3 1 4 2 2 3 1 2가 있다면
(1 1 3 1)은 4에서 판것 (2 2)은 3에서 판것 (1)도 2에서 판것임으로 거꾸로 생각하면
(1)은 3을 만나기전까지 2의 가격으로 판것 (2 2)는 4를 만나기 전까지 3의 가격으로 판것이다
"""

n = int(input())
for i in range(n):
    totalday = int(input())
    arr = list(map(int, input().split()))
    temp = 0
    price = 0
    for i in arr[::-1]:
        if i>temp:
            temp = i
        else:
            price += temp - i
    print(price)


